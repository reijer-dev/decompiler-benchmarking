package nl.ou.debm.common;

import nl.ou.debm.common.antlr.LLVMIRBaseListener;
import nl.ou.debm.common.antlr.LLVMIRLexer;
import nl.ou.debm.common.antlr.LLVMIRParser;
import nl.ou.debm.producer.IFeature;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.ParseTreeWalker;

import java.util.*;
import java.util.regex.Pattern;


/**
 * The CodeMarker class essentially serves as a wrapper for a hashmap containing a set
 * of name/value-combinations. The name is the key, the value is the value.
 * The wrapper's added value lies in mapping the map to a String that can be used in the code.
 * The toString-method from the hash-class cannot be used, as it doesn't escape characters it uses
 * to separate fields and values. This wrapper does! It also assures that no double quotes
 * show up in the resulting String, so it can be used as output for a C-function call such as
 * printf("...wrapper_string...");<br>
 * The wrapper also makes sure whenever a value is queried, the return is always a valid String-object,
 * though of course, it may be empty.<br>
 * <br>
 * Using JSON was considered. However: JSON used double quotes, which would have to be escaped manually
 * in order to be able to use the resulting string in C-code. Furthermore, JSON output may be
 * lay-outed (indents and LF's). These would also have to be undone.<br>
 * The outputted string will always start with a publicly available GUID, followed by a feature code. This
 * makes it very easy to distinguish between any string and a code marker string, and it also helps to
 * distinguish code makers created by the several features.<br>
 * <br>
 * CodeMarker is abstract, so direct property access is shielded. It is recommended to write a child class
 * specific to the feature using the CodeMarker, so that child class can set and get properties, hiding
 * the property names in constants in the child class.
 */

public abstract class CodeMarker {

    // constants
    private static final char PROPERTYSEPARATOR =',';       // separates properties
    private static final char VALUESEPARATOR =':';          // separates property name from property value
    private static final char DOUBLEQUOTES ='\"';           // escape necessary to use the toSting-result as a string in C-code
    private static final char ESCAPECHAR ='\\';             // escapes special separator chars
    private static final char[] ESCAPESEQUENCE = {ESCAPECHAR, PROPERTYSEPARATOR, VALUESEPARATOR, DOUBLEQUOTES};
    private static final String STRDECIMALFIELD = "__DECIMAL_FIELD__";  // special field to be used with printf
    private static final String STRFLOATFIELD = "__FLOAT_FIELD__";  // special field to be used with printf
    private static final String STRAUTOGEN = "AUTOGENERATED";       // field to determine whether the code marker was autogenerated
    public static final String STRCODEMARKERGUID = "c5852db2-7acb-cba3-7f81-e7ef3cd1d3b8";  // makes sure this is not an ordinary string, but a code marker string
    private static final String STRHEADEREND = ">>";                                        // end marker for header

    // the actual map, containing all the data
    private final HashMap<String, String> propMap = new HashMap<>();
    //Regex pattern to find code markers from C-code
    private final static HashMap<EFeaturePrefix, Pattern> _C_patterns = new HashMap<>();
    //Regex pattern to find code markers from LLVM-code
    private final static HashMap<EFeaturePrefix, Pattern> _LLVM_patterns = new HashMap<>();

    // ID-fields
    private static long lngNextCodeMarkerID=1;  // keep track of the ID's
    private static final String STRIDFIELD="ID";      // property name for ID field
    private String strFeatureCode = "";                 // feature that created this CodeMarker

    /**
     * This class serves as a struct. It contains data about code markers found in an LLVM-IR file
     */
    public static class CodeMarkerLLVMInfo{
        /**
         * Only constructor.
         * @param cm CodeMarker object that represents the code marker found
         */
        public CodeMarkerLLVMInfo(CodeMarker cm){
            codeMarker = cm;
        }
        public final CodeMarker codeMarker;                             // the CM-object
        public long iNOccurrencesInLLVM = 0;                            // the number of times this CM occurs in code
        public List<String> strLLVMFunctionNames = new ArrayList<>();   // non-duplicate array of function names in which it occurs
    }

    /**
     * This is a private class to have a walk through the LLVM-file, using ANTLR. As it is
     * specific to the CodeMarker code, it is implemented here
     */
    private static class CodeMarkerLLVMListener extends LLVMIRBaseListener {
        /**
         * Perform the search on a given tree, representing the LLVM file.
         * @param tree  parser tree to be searched
         * @return  map of code marker info, indexed by the code marker ID
         */
        public static Map<Long, CodeMarkerLLVMInfo> DoTheSearch(LLVMIRParser.CompilationUnitContext tree){
            Map<Long, CodeMarkerLLVMInfo> out = new HashMap<>();
            var walker = new ParseTreeWalker();
            var listener = new CodeMarkerLLVMListener(out);
            // the listener needs to do multiple passes, because LLVM allows global string definitions
            // and function definitions to be mixed
            while (listener.bSearchAgain()) {
                walker.walk(listener, tree);
            }
            // make sure that all the function names have no doubles
            for (var item : listener.m_InfoMap.entrySet()){
                item.getValue().strLLVMFunctionNames = new ArrayList<>(new LinkedHashSet<>(item.getValue().strLLVMFunctionNames));
            }
            // and return the lot
            return listener.m_InfoMap;
        }

        private int m_iCallInstructionNestingLevel = 0;         // to ensure that a call within a call would not be a problem
        private boolean m_bLeaveGlobalIdentifiers = true;       // pass control
        private boolean m_bLeaveFunctionCalls = true;           // pass control
        private int m_iCurrentSearchState = 0;                  // pass control
        private final Map<Long, CodeMarkerLLVMInfo> m_InfoMap;  // output
        private final Map<String, Long> m_L2CMIdentifierMap = new HashMap<>();  // map LLVM identifiers to code marker identifiers
        private String m_strCurrentFunctionName;                // keep track of function currently worked in

        /**
         * only constructor, sets map to be used for output
         * @param map  output map
         */
        private CodeMarkerLLVMListener(Map<Long, CodeMarkerLLVMInfo> map){
            m_InfoMap = map;
            map.clear();
        }

        /**
         * to be used in search loop; see static function using it for example
         * @return true if another walk is needed, false if otherwise
         */
        private boolean bSearchAgain(){
            if (m_iCurrentSearchState>=2){
                return false;
            }
            m_iCurrentSearchState++;
            m_bLeaveGlobalIdentifiers = (m_iCurrentSearchState != 1);
            m_bLeaveFunctionCalls = (m_iCurrentSearchState != 2);
            return true;
        }

        /**
         * mark a call instruction entered. The mark is used elsewhere.
         * @param ctx the parse tree
         */
        @Override
        public void enterCallInst(LLVMIRParser.CallInstContext ctx) {
            super.enterCallInst(ctx);

            // only search in call instructions in correct phase
            if (m_bLeaveFunctionCalls){
                return;
            }

            // internal mark: we are in a call instruction
            m_iCallInstructionNestingLevel++;
        }

        /**
         * un-mark a call instruction entered; mark is used elsewhere
         * @param ctx the parse tree
         */
        @Override
        public void exitCallInst(LLVMIRParser.CallInstContext ctx) {
            super.exitCallInst(ctx);

            // only search in call instructions in correct phase
            if (m_bLeaveFunctionCalls){
                return;
            }
            // internal mark: we are no longer in the last call instruction
            m_iCallInstructionNestingLevel--;
        }

        /**
         * keep track of current definition function name
         * @param ctx the parse tree
         */
        @Override
        public void enterFuncDef(LLVMIRParser.FuncDefContext ctx) {
            super.enterFuncDef(ctx);

            // only do when necessary
            if (m_bLeaveFunctionCalls){
                return;
            }

            m_strCurrentFunctionName = ctx.funcHeader().GlobalIdent().getText();
        }

        /**
         * Try to find global identifiers being used in a function call
         * @param ctx the parse tree
         */
        @Override
        public void enterEveryRule(ParserRuleContext ctx) {
            super.enterEveryRule(ctx);

            // only 1+ when marked by enterCallInst, so no
            // need for phase testing, as enterCallInst does that already
            if (m_iCallInstructionNestingLevel <1){
                return;
            }

            // use information
            var x = ctx.getTokens(LLVMIRLexer.GlobalIdent);
            for (var item: x){
                String LLVM_ID = item.getText();
                Long CM_ID = m_L2CMIdentifierMap.get(LLVM_ID);
                if (CM_ID!=null) {
                    // the LLVM_ID is in our map, so we process the wanted data
                    var ci = m_InfoMap.get(CM_ID);
                    ci.iNOccurrencesInLLVM++;
                    ci.strLLVMFunctionNames.add(m_strCurrentFunctionName);
                }
            }

        }

        /**
         * Make a map of all global definitions that have code markers
         * @param ctx the parse tree
         */
        @Override
        public void enterGlobalDef(LLVMIRParser.GlobalDefContext ctx) {
            super.enterGlobalDef(ctx);

            // only search in globals in correct phase
            if (m_bLeaveGlobalIdentifiers){
                return;
            }

            // check if global definition contains a code marker /any/ code marker
            var gcm = CodeMarker.findInGlobalDef(ctx.getText());
            if (gcm==null){
                return;
            }

            // remember global identifier and code marker ID
            m_L2CMIdentifierMap.put(ctx.GlobalIdent().toString(), gcm.lngGetID());
            // setup corresponding code marker object
            m_InfoMap.put(gcm.lngGetID(), new CodeMarkerLLVMInfo(gcm));
        }
    }

    // constructors

    /**
     * Constructor, setting up code marker and including the producing feature's ID-code
     * @param feature   The producer feature class that creates this code marker
     */
    public CodeMarker(IFeature feature){
        // set ID
        setID();
        // set feature code
        setFeatureCode(feature);
    }

    /**
     * Constructor, setting up code marker and including a specified feature prefix
     * @param prefix   Prefix to be used
     */
    public CodeMarker(EFeaturePrefix prefix){
        // set ID
        setID();
        // set feature code
        setFeatureCode(prefix);
    }

    /**
     * Construct a new class and import values directly from the string.
     * When provided, the marker's ID is copied from string. If not, a new
     * one is provided.
     * @param strCodedProperties    see: {@link #fromString(String)}
     */
    public CodeMarker(String strCodedProperties){
        // construct directly from string
        fromString(strCodedProperties);
    }

    /**
     * Construct a new class and import values directly from another code marker.
     * The new copy will have a unique ID.
     * @param codeMarker            property source
     */
    public CodeMarker(final CodeMarker codeMarker){
        // copy constructor
        fromCodeMarker(codeMarker);
        setID();
        this.strFeatureCode = codeMarker.strFeatureCode;
    }

    // hashmap access

    /**
     * Clear property table
     */
    protected void clear(){
        long lngID = lngGetID();
        propMap.clear();
        setID(lngID);
    }

    /**
     * Set a new value for a property (add property if not present yet)
     * Updating ID-field is not possible. Updating feature code is only
     * possible by using SetFeatureCode
     * @param strPropertyName   name of the property
     * @param strPropertyValue  value of the property
     */
    protected void setProperty(String strPropertyName, String strPropertyValue){
        if (!strPropertyName.equals(STRIDFIELD)) {
            propMap.put(strPropertyName, strPropertyValue);
        }
    }

    /**
     * check whether or not property is present in the map
     * @param strPropertyName property name to be checked
     * @return true is present, otherwise false
     */
    protected boolean bPropertyPresent(String strPropertyName){
        return propMap.containsKey(strPropertyName);
    }

    /**
     * Sets a code that identifies the feature that created the marker
     * @param feature   the feature whose prefix is to be used
     */
    public void setFeatureCode(IFeature feature){
        this.strFeatureCode = feature.getPrefix();
    }

    /**
     * Sets a code that identifies the feature that created the marker
     * @param prefix   the prefix to be used
     */
    public void setFeatureCode(EFeaturePrefix prefix){
        this.strFeatureCode = prefix.toString();
    }

    private void setID(){
        long id = lngNextCodeMarkerID++;
        setID(id);
    }
    private void setID(long lngID){
        propMap.put(STRIDFIELD, Long.toHexString(lngID));
    }

    public void setAutoGeneratedFlag(boolean bAutomaticallyGenerated){
        if (bAutomaticallyGenerated){
            propMap.put(STRAUTOGEN,"T");
        }
        else {
            propMap.remove(STRAUTOGEN);
        }
    }

    public boolean bGetAutoGeneratedFlag(){
        return propMap.containsKey(STRAUTOGEN);
    }

    /**
     * Make sure a property is added with "%d" as value. When it comes
     * to making a marker, this part of the string can be used by printf
     * to print a decimal variable
     */
    public void AddIntegerField(){
        setProperty(STRDECIMALFIELD, "%d");
    }

    /**
     * Make sure a property is added with "%f" as value. When it comes
     * to making a marker, this part of the string can be used by printf
     * to print a decimal variable
     */
    public void AddFloatField(){
        setProperty(STRFLOATFIELD, "%f");
    }

    /**
     * Get value for a property.
     * @param strPropertyName   name of the property
     * @return                  value of the property. If not set, it returns an empty string ("")
     */
    protected String strPropertyValue(String strPropertyName){
        String out = propMap.get(strPropertyName);
        if (out == null){
            return "";
        }
        return out;
    }

    public Long lngGetID(){
        return Misc.lngRobustHexStringToLong(propMap.get(STRIDFIELD));
    }

    /**
     * Remove a property from the list (if it was on the list, otherwise nothing happens)
     * @param strPropertyName   name of the property
     */
    protected void removeProperty(String strPropertyName){
        if (!strPropertyName.equals(STRIDFIELD)){
            propMap.remove(strPropertyName);
        }
    }

    /**
     * Get number of properties
     * @return  number of properties
     */
    public int iNProperties(){
        return propMap.size();
    }

    /**
     * Map the properties to one single string, make sure that the proper characters are escaped.
     * @return      string containing property information. Use as input for {@link #fromString(String)}
     */
    public String toString(){
        var sb = new StringBuilder();
        sb.append(STRCODEMARKERGUID);
        sb.append(strFeatureCode);
        sb.append(STRHEADEREND);
        for (var s : propMap.entrySet()){
            sb.append(strEscapeString(s.getKey()));
            sb.append(VALUESEPARATOR);
            sb.append(strEscapeString(s.getValue()));
            sb.append(PROPERTYSEPARATOR);
        }
        return sb.substring(0, sb.length() - 1);
    }

    /**
     * Initialize table from a given string. Thus, a marker that was created and exported
     * using toString (@see toString) can be converted back to a property list, making it
     * easier to query the properties and their values.
     * The current list of properties is thrown out.
     * This function ignores any string that does not start with the code marker GUID.
     * @param strCodedProperties    String containing the property information. Use the output of
     *                              {@link #toString()}
     */
    public void fromString(String strCodedProperties){
        fromString(strCodedProperties, true);
    }

    /**
     * Initialize table from a given string. Thus, a marker that was created and exported
     * using toString (@see toString) can be converted back to a property list, making it
     * easier to query the properties and their values.
     * The current list of properties is only thrown out if flag to clear table is set. If
     * the flag is not set, the imported information is simply applied to the existing data,
     * adding or updating properties.
     * This function ignores any string that does not start with the code marker GUID.
     * @param strCodedProperties    see {@link #fromString(String)}
     * @param bClearTable           true means table is cleared before processing
     */
    public void fromString(String strCodedProperties, boolean bClearTable){
        // check validity of string
        if (!strCodedProperties.startsWith(STRCODEMARKERGUID)){
            // ignore any non-code-marker
            return;
        }

        // find code marker header end
        int iHeaderEndMarkerPos = strCodedProperties.indexOf(STRHEADEREND);
        if (iHeaderEndMarkerPos<0){
            // ignore any non-code-marker
            return;
        }

        // extract code marker creating feature code
        strFeatureCode = strCodedProperties.substring(STRCODEMARKERGUID.length(), iHeaderEndMarkerPos);
        if (strFeatureCode.isEmpty()){
            // ignore any non-code marker
            return;
        }

        // clear map
        if (bClearTable) {
            clear();
        }

        // split at properties level
        var p = strCodedProperties.substring(iHeaderEndMarkerPos + STRHEADEREND.length()).split("" + PROPERTYSEPARATOR );
        for (var prop : p){
            // split name/value
            var v = prop.split("" + VALUESEPARATOR);
            // only do something if there are exactly two entries
            if (v.length == 2){
                propMap.put(strDeEscapeString(v[0]), strDeEscapeString(v[1]));
            }
        }

        // check ID
        if (!bPropertyPresent(STRIDFIELD)){
            // no ID in string. Strange, but possible --> simply set new ID
            setID();
        }
        else{
            // there was an ID in the string. Make sure no conflicts can occur by auto-numbering
            long lID = lngGetID();
            if (lngNextCodeMarkerID<=lID) {
                lngNextCodeMarkerID=lID + 1;
            }
        }
    }



    /**
     * Construct a new class and import values directly from a C-statement
     * Returns null when no code marker with this prefix is found
     * @param prefix            prefix to determine the type of code marker
     * @param cStatement        cStatement that possibly contains a code marker
     */
    public static CodeMarker findInStatement(EFeaturePrefix prefix, String cStatement){
        var matcher = _C_patterns.get(prefix).matcher(cStatement);
        return matcher.find() ? EFeaturePrefix.createNewFeaturedCodeMarker(prefix, matcher.group(1)) : null;
    }

    /**
     * Construct a new class and import values directly from a LLVM-declaration
     * Returns null when no code marker with this prefix is found
     * @param prefix            prefix to determine the type of code marker
     * @param strGlobalDefinition    definition that possibly contains a code marker
     */
    public static CodeMarker findInGlobalDef(EFeaturePrefix prefix, String strGlobalDefinition){
        var matcher = _LLVM_patterns.get(prefix).matcher(strGlobalDefinition);
        return matcher.find() ? EFeaturePrefix.createNewFeaturedCodeMarker(prefix, strStripFrays(matcher.group())) : null;
    }
    /**
     * Construct a new class and import values directly from a LLVM-declaration
     * Returns null when no code marker is found. All different code markers are tried.
     * @param strGlobalDefinition    definition that possibly contains a code marker
     */    public static CodeMarker findInGlobalDef(String strGlobalDefinition){
        for (var prefix : EFeaturePrefix.values()) {
            var matcher = _LLVM_patterns.get(prefix).matcher(strGlobalDefinition);
            if (matcher.find()) {
                return EFeaturePrefix.createNewFeaturedCodeMarker(prefix, strStripFrays(matcher.group()));
            }
        }
        return null;
    }

    /**
     * Aux routine to strip of some characters not wanted after a search
     */
    private static String strStripFrays(String strIn){
        return strIn.substring(1, strIn.length()-4);
    }

    public static boolean isInStatement(EFeaturePrefix prefix, String cStatement){
        return _C_patterns.get(prefix).matcher(cStatement).find();
    }

    //Precompile regex patterns for all features
    static {
        for(var prefix : EFeaturePrefix.values()) {
            _C_patterns.put(prefix, Pattern.compile(".+\\(\"(" + STRCODEMARKERGUID + prefix + ">>.+)\"", Pattern.CASE_INSENSITIVE));
            _LLVM_patterns.put(prefix, Pattern.compile( "\"" + STRCODEMARKERGUID + prefix + ">>.+\\Q\\\\E00\"", java.util.regex.Pattern.CASE_INSENSITIVE));
        }
    }

    /**
     * Get information on code markers in a parsed LLVM file.
     * @param lparser the parser representing the data
     * @return info, sorted by code marker ID
     */
    public static Map<Long, CodeMarkerLLVMInfo> getCodeMarkerInfoFromLLVM(LLVMIRParser lparser){
        return CodeMarkerLLVMListener.DoTheSearch(lparser.compilationUnit());
    }

    /**
     * Copy all the date from another CodeMarker object
     * @param originalCodeMarker    data source
     */
    public void fromCodeMarker(final CodeMarker originalCodeMarker){
        fromString(originalCodeMarker.toString());
    }

    /**
     * Make sure escape characters are put in place
     * @param strIn     raw string input
     * @return          escaped string
     */
    private String strEscapeString(String strIn){
        for (int p=0; p<ESCAPESEQUENCE.length ; ++p){
            strIn = strIn.replace("" + ESCAPESEQUENCE[p], "" + ESCAPECHAR + p);
        }
        return strIn;
    }

    /**
     * Make sure escape characters are replaced by their originals
     * @param strIn     escaped string input
     * @return          raw string output
     */
    private String strDeEscapeString(String strIn){
        for (int p=ESCAPESEQUENCE.length-1; p>=0 ; --p){
            strIn = strIn.replace( "" + ESCAPECHAR + p, "" + ESCAPESEQUENCE[p]);
        }
        return strIn;
    }

    /**
     * Return a complete code marker statement, which comes down to: printf([codeMarker_in_double_quotes]);
     * @return  the appropriate printf-statement
     */
    public String strPrintf(){
        return "printf(\"" + this + "\");";
    }

    public String strPrintfInteger(String strVariableName){
        // make sure a decimal field is added
        AddIntegerField();
        return "printf(\"" + this + "\", " + strVariableName + ");";
    }

    public String strPrintfFloat(String strVariableName){
        // make sure a decimal field is added
        AddFloatField();
        return "printf(\"" + this + "\", " + strVariableName + ");";
    }
}
