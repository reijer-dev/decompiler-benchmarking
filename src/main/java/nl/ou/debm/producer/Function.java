package nl.ou.debm.producer;

import java.util.ArrayList;
import java.util.List;

import static nl.ou.debm.common.Misc.strTrimRight;

public class Function {

    private static long lngFunctionCounter = 0;     // keep track of the number of created functions for autoname

    private String name;                    // function name
    private DataType type;                  // function return-datatype
    private final List<FunctionParameter> parameters = new ArrayList<>();   // function parameter list
    private final List<String> statements = new ArrayList<>();  // function statements
    private boolean hasVarArgs = false;
    private boolean isCallable = true;

    /**
     * Construct a function object
     * @param type  function name
     * @param name  function return data type (may be void, may not be empty)
     */
    public Function(DataType type, String name){
        setType(type);
        setName(name);
    }
    public Function(DataType type){
        setType(type);
        setName("function_" + (lngFunctionCounter++));
    }

    /**
     * Emit the code to a StringBuilder-object that accumulates all the generated c-code parts
     * @param sb    StringBuilder to which this functions written code will be added.
     */
    public void appendCode(CGenerator generator, StringBuilder sb){
        sb.append('\n');                                    // new line
        sb.append(type.getNameForUse());                    // return type
        sb.append(' ');
        sb.append(name);                                    // function name
        sb.append('(');                                     // list parameters

        if(parameters.size() == 0)
            sb.append("void");

        for(var i = 0; i < parameters.size(); i++){
            if(i > 0)
                sb.append(", ");
            parameters.get(i).appendCode(sb);
        }

        if(hasVarArgs) {
            if(parameters.size() > 0)
                sb.append(", ");
            sb.append("...");
        }

        sb.append("){\n");

        for(var injector : generator.functionBodyInjectors) {
            var startMarker = injector.appendCodeMarkerAtStart(this);
            startMarker.setProperty("autoGeneratedFunctionStartMarker", "true");
            sb.append(startMarker.strPrintf());
            sb.append('\n');
        }

        var endStatementsPrinted = false;
        for(var statement : statements){                    // list all statements
            if(statement.trim().startsWith("return ")) {
                appendEndStatements(generator,sb);
                endStatementsPrinted = true;
            }
            sb.append('\t');
            sb.append(statement);
            sb.append('\n');
        }
        if(!endStatementsPrinted)
            appendEndStatements(generator,sb);

        sb.append("}\n");                                 // close function
    }

    private void appendEndStatements(CGenerator generator, StringBuilder sb){
        for(var injector : generator.functionBodyInjectors) {
            sb.append('\t');
            var endMarker = injector.appendCodeMarkerAtEnd(this);
            endMarker.setProperty("autoGeneratedFunctionEndMarker", "true");
            sb.append(endMarker.strPrintf());
            sb.append('\n');
        }
    }

    // getters & setters
    // =================
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public DataType getType() {
        return type;
    }

    public void setType(DataType type) {
        this.type = type;
    }

    public void setHasVarArgs(boolean hasVarArgs){ this.hasVarArgs = hasVarArgs; }
    public boolean hasVarArgs(){ return this.hasVarArgs; }

    public List<FunctionParameter> getParameters(){
        return parameters;
    }

    // Add new information to function
    public void addParameter(FunctionParameter parameter){
        parameters.add(parameter);
    }

    /**
     * Add single statement to a function.
     * The caller is responsible for the correct syntax of the statement
     * added. That means that the caller must terminate the statement with ; when
     * required by the C standard. It is not forbidden to add multiple statements
     * in one single string, but it is recommended to use a list as parameter.
     * @param statement     String representing the statement to be added.
     */
    public void addStatement(String statement){
        statements.add(strTrimRight(statement));
    }

    /**
     * see: {@link Function#addStatements(List)}
     * @param newStatements String list containing new statements
     */
    public void addStatements(List<String> newStatements) {
        for (var statement : newStatements) {
            statements.add(strTrimRight(statement));
        }
    }

    public boolean isCallable() {
        return isCallable;
    }

    public void setCallable(boolean callable) {
        isCallable = callable;
    }
}
